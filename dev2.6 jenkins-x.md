### the-devops-2-6-toolkit-sample学习笔记

- - [十条戒律](https://editor.csdn.net/md/?articleId=106733953#_2)

  - - [部署到staging环境，我们该进哪些测试？](https://editor.csdn.net/md/?articleId=106733953#staging_102)
    - [探索和使用staging 环境](https://editor.csdn.net/md/?articleId=106733953#staging__116)
    - [理解应用和环pipeline的关系](https://editor.csdn.net/md/?articleId=106733953#pipeline_130)
    - [控制环境](https://editor.csdn.net/md/?articleId=106733953#_136)
    - [我们遵守了所有的戒律？](https://editor.csdn.net/md/?articleId=106733953#_152)

  - [改进和简化软件开发](https://editor.csdn.net/md/?articleId=106733953#_155)

  - - [探索高效开发环境的要求](https://editor.csdn.net/md/?articleId=106733953#_161)
    - [Creating A Kubernetes Cluster With Jenkins X AndImporting The Application](https://editor.csdn.net/md/?articleId=106733953#Creating_A_Kubernetes_Cluster_With_Jenkins_X_AndImporting_The_Application_166)
    - [Creating a Remote Development Environment](https://editor.csdn.net/md/?articleId=106733953#Creating_a_Remote_Development_Environment_169)
    - [Working With The Code In The DevPod Using Browser-Based IDE 基于浏览器](https://editor.csdn.net/md/?articleId=106733953#Working_With_The_Code_In_The_DevPod_Using_BrowserBased_IDE__282)
    - [将笔记本电脑中的代码同步到DevPod Synchronizing Code From A Laptop Into A DevPod](https://editor.csdn.net/md/?articleId=106733953#DevPod_Synchronizing_Code_From_A_Laptop_Into_A_DevPod_301)
    - [集成Integrating IDEs With Jenkins X](https://editor.csdn.net/md/?articleId=106733953#Integrating_IDEs_With_Jenkins_X_318)

  - [Working With Pull Requests AndPreview Environments![在这里插入图片描述](assets/20200614003751528.png)](https://editor.csdn.net/md/?articleId=106733953#Working_With_Pull_Requests_AndPreview_Environmentshttpsimgblogcsdnimgcn20200614003751528pngxossprocessimagewatermarktype_ZmFuZ3poZW5naGVpdGkshadow_10text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Fpbmd5ZWppYXpodQsize_16color_FFFFFFt_70_326)

  - - [Creating A Kubernetes Cluster With Jenkins X AndImporting The Application](https://editor.csdn.net/md/?articleId=106733953#Creating_A_Kubernetes_Cluster_With_Jenkins_X_AndImporting_The_Application_337)
    - [Creating Pull Requests](https://editor.csdn.net/md/?articleId=106733953#Creating_Pull_Requests_339)
    - [Intermezzo 幕间剧、间奏曲](https://editor.csdn.net/md/?articleId=106733953#Intermezzo__341)
    - [Merging a PR](https://editor.csdn.net/md/?articleId=106733953#Merging_a_PR_343)
    - [Exploring Jenkins X Garbage Collection 垃圾回收](https://editor.csdn.net/md/?articleId=106733953#Exploring_Jenkins_X_Garbage_Collection__345)

  - [Promoting Releases To Production](https://editor.csdn.net/md/?articleId=106733953#Promoting_Releases_To_Production_348)

  - [Versioning Releases 版本控制](https://editor.csdn.net/md/?articleId=106733953#Versioning_Releases__351)

  - - [解释语义版本控制 Semantic Versioning Explained](https://editor.csdn.net/md/?articleId=106733953#_Semantic_Versioning_Explained_353)
    - [Versioning Releases Through Tags](https://editor.csdn.net/md/?articleId=106733953#Versioning_Releases_Through_Tags_356)
    - [从Jenkins XPipelines控制发布版本](https://editor.csdn.net/md/?articleId=106733953#Jenkins_XPipelines_359)
    - [Customizing Versioning Logic](https://editor.csdn.net/md/?articleId=106733953#Customizing_Versioning_Logic_361)
    - [Versioning With Maven, NodeJS, And Other Build Tools](https://editor.csdn.net/md/?articleId=106733953#Versioning_With_Maven_NodeJS_And_Other_Build_Tools_363)

  - [Going Serverless 探索Prow，Jenkins X管道运营商，和Tekton](https://editor.csdn.net/md/?articleId=106733953#Going_Serverless_ProwJenkins_XTekton_365)

  - [Implementing ChatOps 聊天室](https://editor.csdn.net/md/?articleId=106733953#Implementing_ChatOps__367)

  - - [通过chatops探索基本的Pull请求过程](https://editor.csdn.net/md/?articleId=106733953#chatopsPull_369)
    - [Exploring Additional Slash （其他斜杠命令）Commands](https://editor.csdn.net/md/?articleId=106733953#Exploring_Additional_Slash_Commands_371)
    - [我们如何知道哪些斜杠命令是可用的？](https://editor.csdn.net/md/?articleId=106733953#_373)

  - [Using The Pipeline Extension Model](https://editor.csdn.net/md/?articleId=106733953#Using_The_Pipeline_Extension_Model_376)

  - - [Jenkins Jobs的发展以及我们如何达到基于yaml的Jenkins-x.yml格式](https://editor.csdn.net/md/?articleId=106733953#Jenkins_JobsyamlJenkinsxyml_378)
    - [消除重复 getting rid of repetition](https://editor.csdn.net/md/?articleId=106733953#_getting_rid_of_repetition_381)
    - [Exploring Build Pack Pipelines](https://editor.csdn.net/md/?articleId=106733953#Exploring_Build_Pack_Pipelines_383)
    - [Extending Build Pack Pipelines](https://editor.csdn.net/md/?articleId=106733953#Extending_Build_Pack_Pipelines_385)
    - [Extending Environment Pipelines](https://editor.csdn.net/md/?articleId=106733953#Extending_Environment_Pipelines_387)

  - [Extending Jenkins X Pipelines](https://editor.csdn.net/md/?articleId=106733953#Extending_Jenkins_X_Pipelines_389)

  - [使用Jenkins X定义和运行无服务器部署](https://editor.csdn.net/md/?articleId=106733953#Jenkins_X_391)

  - [Choosing The Right DeploymentStrategy](https://editor.csdn.net/md/?articleId=106733953#Choosing_The_Right_DeploymentStrategy_393)

  - [将GitOps原理应用于JenkinsX](https://editor.csdn.net/md/?articleId=106733953#GitOpsJenkinsX_395)

  - [Managing Third-Party Applications](https://editor.csdn.net/md/?articleId=106733953#Managing_ThirdParty_Applications_397)



## 十条戒律

- git 是唯一源

> All application-specific code in its raw format must be stored in Git. By code, I meannot only the code of your application, but also its tests, configuration, and everything else that isspecific to that app or the system in general.
> 所有原始格式的应用程序特定代码都必须存储在Git中。在代码方面，我指的不仅是应用程序的代码，还有它的测试、配置和其他所有与该应用程序或系统相关的东西。

idempotent 等幂，服务其上的执行命令通常不是idempotent的。

- 一切必须被跟踪，每一个动作都必须是可重复的，并且每一个动作都必须是等幂的。Everything must be tracked, every action must be reproducible,and everything must be idempotent.

  More often thannote, that would be YAML or JSON files that describe the desired outcome, instead of imperativescripts. 通常情况下，这将是描述所需结果的YAML或JSON文件，而不是必需的描述。
  每次改变必须被记录

  我们不能做什么？
  不允许通过直接在ProductionServer内部更改代码来添加应用程序的功能。
  我们需要代理，我们请求一些东西，我们得到一个确认，然后我们回到我们正在做的事情上。

- 如果要并行执行操作，进程之间的通信必须是异步的。

  communication between processes must be asynchronousif operationsare to be executed in parallel.
  如果我们已经同意，唯一的真相来源是Git（这是所有信息的来源），那么异步通信的逻辑选择是webhook。

  根据所需的状态，应该聚合系统的参与者可以是Kubernetes、Helm、Istio、cloud或on-prem提供者，或者许多其他工具之一。通常，多个进程需要并行执行一些操作。如果我们只依赖于网络钩子，那就有问题了。我们需要一个
  We needsomeone (or something) to make decisions and make sure that each desire is converted into a setof actions and assigned to different actors (processes).

  管家是jx的一部，最好是serverless的。

  每个更改为Git会触发对Jenkins X包中某个组件的webhook请求。反过来，它只以一个确认（ACK）来响应，让Git知道它收到了一个请求。

- processes should run for as long as needed,but not longer. 进程应该根据需要运行更长的时间，而不是长期运行。

  要的是，所有闲置的东西都必须被消灭，所有活着的人都应该拥有他们所需要的一切资源。jx组织临时的pod执行管道步骤。

  在大多数情况下，我们的管道将生成一些二进制文件。它们可以是库、容器图像、Helm包和许多其他包。其中一些可能是临时的，只在构建的持续时间内才需要。一个很好的例子就是应用程序的二进制文件。我们需要它来生成一个容器图像。之后，我们也可以删除它，因为部署应用程序只需要这个映像。因为我们在容器中运行步骤，所以不需要删除任何内容，因为一旦构建完成，它们包含的吊舱和容器就会被移除。然而，并不是所有的二进制文件都是临时的。我们确实需要在某个地方存储容器图像。否则，我们将无法在集群内运行它们。对于Helm图表、库（那些使用依赖关系的库）和许多其他的库也是如此。为此，我们有不同的应用程序，如Docker registry（容器图像）、ChartMuseum（头盔图表）、Nexus（库）等。重要的是，我们只存储二进制文件，而不是代码、配置和其他原始文本文件。这些必须转到Git，因为这是我们跟踪更改的地方，这是我们进行代码评审的地方，这是我们期望它们出现的地方。现在，在某些情况下，在注册表中保留原始文件也是有意义的。它们可能是将它们分发给某些组的更简单的方法。

- 有二进制文件必须存储在注册表中

  只有在这样有助于分发的同时理解这些文件不是真相的来源时，原始文件才能存在

  PR提供了一种简单的方法来跟踪变化和背后的意图。

- information about all the releases must be stored in environment-specific repositories or branches

- everything must follow the same coding practices(environments included).

  有关所有版本的信息必须存储在特定于环境的存储库或分支中，并且所有内容都必须遵循相同的编码实践（包括环境）。

  Reproducibility is one of the key features we’re looking for.
  可再现性

  While scripts provide repetition, declarative approach gives us idempotency.声明式的

  But why do we want to use declarative syntax to describe our systems? The main reason is in idempotency provided through our expression of a desire, instead of imperative statements.主要原因在于我们通过表达欲望而不是命令语句来提供等幂性。

我们不仅要让机器做体力劳动，而且要让机器符合我们的要求。

- All deployments must be idempotent 等幂

- Git webhooks are the only ones allowed to initiate a change that will be applied to the system.

  所有这些特权（kubectl 访问API）都应该委托给机器，我们（人工）的工作应该是创建或更新代码、配置和定义，将更改推送到Git，并让机器完成其余的工作。（自动化的工具）这些工具必须首先设计为API，其次才是UI（以及其他任何东西）。

  Automation自动化 relies依赖 on APIs and CLIs (they areextensions of APIs), not on UIs and editors.

- All the tools must be able to speak with each other through APIs.

------

我们定义了哪些规则：

1.Git is the only source of truth.

2.Everything must be tracked被跟踪, every action must be reproducible可重复, and everything must be idempotent.

3.Communication between processes must be asynchronous异步.

4.Processes should run for as long as needed, but not longer.

5.All binaries must be stored in registries.

6.Information about all the releases must be stored in environment-specific repositories or branches.

7.Everything must follow the same coding practices.

8.All deployments must be idempotent.

9.Git webhooks are the only ones allowed to initiate a change that will be applied to the system.

10.All the tools must be able to speak with each other through APIs

------

staging环境是我们为最后一轮测试安装（或升级）新版本的地方。被设置为自动升级。

生产环境手动推送

现在，我们要关注我们所处的环境远。我们只有三个环境。数量如此之少，我们在列出它们时可能不需要使用filters。但是，这个数字很快就会增加。根据我们的组织方式，我们可以给每个团队一个单独的环境。Jenkins X实现了一个称为团队的概念。

查看哪些环境自动升级
jx get env --promote Auto

### 部署到staging环境，我们该进哪些测试？

简单定义三组测试

- 第一组测试不依赖于live 应，它们可以是单元测试、静态分析或任何只需要代码的其他类型。这些测试不需要构建程序二进制文件，不需要部署应。

- 第二组是特定于应用程序的测试。对于这些，我们确实需要先部署一个新版本，但不需要整个系统。这些测试在很大程度上依赖于模拟和存根。mocks and stubs

  虽然我认为mock应该在这个阶段替换所有“真正的”应用程序依赖项，但我也知道并不是所有的应用程序都设计为支持尽管如此，需要注意的关键是，特定于应用程序的测试不需要整个系统。

- 第三组测试是系统范围的验证。

  我们可能要检查一个实时应用程序是否与其他实时应用程序集成。我们可能需要确认整个系统的性能在既定的阈值内。在整个系统层面上，我们可能还需要验证许多其他东西。重要的是这个阶段的测试是昂贵的。他们往往比其他人慢，他们往往需要更多的资源。在运行系统范围的验证时，我们不应该做的是重复我们已经做过的检查。我们不运行已经通过的测试，我们试图将这个阶段的测试限制在真正重要的方面（主要是集成和性能），为什么我要解释我们应该运行的测试组？答案在于系统范围的验证。

### 探索和使用staging 环境

Makefile有用于构建、安装和删除Helm图表的目标。

缺少测试，jx不知道我们是否需要测试应。

staging环境是所有互连应用程序驻留的地方。这就是我们在类似生产环境中部署新版本的地方，我们很快就会看到关于新版本的信息存储在哪里。

下面添加测试部分。哈哈。在pipeline中哦。
我们将运行单元测试、功能测试和任何其他类型的特定于应用程序的测试。

假设应已经可以运行了。考虑到这一点，所有在staging阶段需要测试的都是只有当整个系统（或其逻辑和独立部分）启动并且跑步。那些可以是集成、性能或任何其他类型的系统范围验证。

### 理解应用和环pipeline的关系

requirements.yaml始终包含整个环境的完整而准确的定义，每个更改都将是一个新的提交。

What happens when we push something to the master branch of a repository?
![在这里插入图片描述](assets/20200613162445452.png)

### 控制环境

我们可以根据需要创建尽可能多的环境，可以更新现有的环境，也可以删除它们。

```shell
jx create env\
	--name pre-production\
	--label Pre-Production\
	--namespace jx-pre-production\
	--promotion Manual\6--batch-mode
```

删除环境

```
jx delete env pre-production
```

本命令不删除kubernetes中的namespace，不删除创建在github中的repostitory。

### 我们遵守了所有的戒律？

仅仅没遵循Processes should run for as long as needed, but not longer.

## 改进和简化软件开发

团队使用多种语言，使用不同数据库。我们需要每个开发人员都有自己的环境选项，其中应用程序所需的依赖项都在运行。为了依赖项是有用的，我们应该（几乎）像在生产中一样运行它们，这意味着我们也应该将它们部署到Kubernetes。为此，如果我们更喜欢本地集群，我们可以选择minikube或Docker Desktop，或者获取远程群集。很不幸编译器和依赖项并不是我们高效开发所需要的一切。
我们也需要工具。今天这意味着我们需要Docker或kaniko来构建容器图。Helm和Kubectl将应用程序部署到Kubernetes。我们需要将构建映像的过程与部署结合起来的skaffold。对于一种语言和一个框架，还有很多其他的工具需要安装和配置。
甚至如果我们真的设置了所有这些东西，我们仍然缺少更多。我们需要能够从容器注册中心container registry、ChartMuseum、Nexus或任何其他可能在我们的组织你可以想象，安装和配置所有这些并不简单。新员工花一周甚至更长的时间来建立自己的开发环境并不少见。如果那个人应该转移到另一个项目，或者他应该同时处理多个项目，会发生什么？

Jenkins-x允许我们使用所有工具、配置和环境变量来构建一个基于项目的私有开发环境，我们可能需要在任何应用程序上工作。这个特性叫做DevPod。

### 探索高效开发环境的要求

让我们讨论一下我们在开发环境中需要什么，同时考虑到我们在处置理想情况下，我们应该能够克隆一个项目的存储库，并执行一个单独的命令来设置我们需要的一切。该设置应尽可能接近生产环境。否则，我们将冒着局部结果与部署到分期、生产和其他永久性环境的方法不一致的风险。由于我们需要与团队中的其他人以及其他项目的工作人员合作，因此需要将这样的环境需要连接到注册表，我们可以从中pull container images and Helm charts。
最后，开发环境需要一个项目中使用的语言编译器，以及我们需要的所有工具（如skaffold、Helm、Docker等）。另外，如果我们不需要运行构建、测试和部署应用程序的命令，那将是非常好的。每当我们更改一个文件时，环境本身应该构建一个二进制文件，运行测试，并部署一个新版本。这样，我们可以集中精力编写代码，同时让其他事情发生在背景。全部总之，我们需要能够轻松快速地创建一个特定于项目的环境（只需一个命令），这样的环境需要我们可能需要的一切，而无需我们在笔记本电脑上安装或配置（几乎）任何东西。环境应该自动完成所有的基本工作，如编译、测试和部署。这不是一个非常有成效的设置吗？
工作环境：
![在这里插入图片描述](assets/2020061316582787.png)

### Creating A Kubernetes Cluster With Jenkins X AndImporting The Application

略过

### Creating a Remote Development Environment

一旦我们完成对代码的更改，我们将需要编译和测试它，这可能需要额外的安装和配置。一旦我们的代码被编译，我们就需要运行应用程序来确认它的行为符合预期。为此，我们需要Docker来建立一个容器映像，我们需要Helm来部署它。
我们还需要在集群中创建一个个人名称空间，或者创建一个本地名称空间。考虑到我们采用了Skaffold作为构建和部署图像的工具，我们还需要安装它。但我们的麻烦还没有结束。
在部署应用程序之前，我们需要将新的容器映像以及Helm图表推送到集群内运行的注册中心。要做到这一点，我们需要知道他们的地址，我们需要有足够的证件权限。甚至当我们这样做的时候，我们需要一个可重复的过程，当我们做出重大的改变时，这个过程将构建、测试、发布和部署我们的工作。或者，更好的是，无论我们什么时候change。
这里是你的任务。更改代码中的任何内容，编译它，构建一个映像，将其与Helm chart一起发布，将其部署到集群中，并确认结果符合您的预期。我劝你停止阅读，做那些事。你回来的时候完成。如何你花了很多时间才有了新功能？很可能你失败。或，也许，你用jenkins X和前几章的知识来做这些。如果是这样的话，真的有效吗？我敢打赌，要花上几分钟才能建立起全方位的环境。现在，对代码再做一次更改，不要碰其他任何东西。你的更改编译了吗？你的测试执行了吗？你的零钱已经发出去了吗？是不是花了超过几秒钟？如果你失败了，我们将探讨下一次如何使你成功。如果您没有，我们将探讨如何使流程更加简单、高效和快速。我们会用jenkins X，但不会用你的方式期待。

```linux
jx create devpod --label go --batch-mode
the batch mode (no questions asked)
```

第一，Jenkins X在集群中创建了jx-edit-YOUR_USER空间。这将是集群中您的个人部分
。
接下来，Jenkins X安装了exposecontrollerservice。它将与Ingress通信，并使应用程序可供查看和进一步测试。
此外，它更新了DevPod中的 Helm repository，以便我们可以利用集群内运行的ChartMuseum中提供的chart。
我怀疑是 helm add repo http://…之类的。
它还运行了Visual Studio代码。

```
jx rsh --devpod
```

The jx rsh command opens a terminal inside a Pod

------

skaffold

Jenkins X pipelines use skaffold to create container images and deploy our applications.
![在这里插入图片描述](assets/2020061319484859.png)We won’t be using root build and deploy sections of the config. They are reserved 预留for the Jenkins pipeline. There are slight 细微差异differences when building and deploying images to permanent and development environments. Our target is the devprofile. It overwrites the buildand the deploy targets.
在开发构建期间，我们不会传递版本，而是让它通过skaffold的“特殊”变量DIGEST_HEX自动生成。通过它，每个构建都将使用一个唯一的字符串（例如27ffc7f…）进行标记。不幸的是，截至本文撰写之日（2019年5月），该变量现在已被弃用并被删除。我们将不得不更换它，因为在Jenkins X的构建包中还没有解决这个问题的方法。

```shell
cat skaffold.yaml\
	| sed -e's@DIGEST_HEX@UUID@g'\
	| tee skaffold.yaml
```

可能这个问题现在已经解决了。
devprofile的deploy部分将类型从kubectl更改为helm。它将chartPath设置为charts/go-demo-6，以便在存储库。进一步下来，它覆盖图像.repository、image.tag Helm Value。这样它们就和我们刚建立的image相符了。
在那个YAML中只剩下未知的DOCKER_REGISTRY。它应该指向存储容器图像的注册表。我们应该自己定义吗？如果我们需要，注册地址是什么？
我已经说过DevPods包含了开发应用程序所需的一切。因此，毫不奇怪Docker_Registry已经为我们定义了。我们可以通过输出它的值来确认。

```linux
echo $DOCKER_REGISTRY
env
```

env输出100多个变量

下一个，我们应该初始化驻留在DevPod中的Helm客户机，以便使用它部署图表。

```shell
kubectl create \
-f https://raw.githubusercontent.com/vfarcic/k8s-specs/master/helm/tiller-rbac.y \
ml \
--record --save-config
helm init --service-account tiller
```

现在我们可以在个人开发环境中构建和部署应用程序了。由于Skaffold不会生成摘要十六进制，也不会生成替换的UUID，因此在运行dev概要文件之前，我们必须创建一个。因此，我们将使用export UUID=$（uuidgen）作为skaffold运行的前缀。

```
skaffold run --profile dev
```

如果您检查输出，您将看到发生了很多事情。它使用我们之前构建的go-demo-6二进制文件构建了一个新的容器映像。之后，它安装了应用程序chart。但是，那个chart是在哪里安装的？我们可以从输出中发现这一点，但有一个更简单的方法。Skaffold安装应用程序的命名空间也定义为环境变量。

echo $SKAFFOLD_DEPLOY_NAMESPACE

在我的例子中，输出是jx edit vfarcic（您将使用不同的用户）。
这是专门用于我开发go-demo-6应用程序的个性化名称空间。
如果我同时处理多个项目，我将为每个项目都有一个名称空间。因此，将有与开发人员并行工作一样多的jx edit-*名称空间，乘以他们正在处理的项目的数量。
当然，这些名称空间是临时的，我们应该在完成一个项目后（或者准备回家时）将它们与DevPods一起删除。
让他们一直运转是浪费。我们会保留我们的DevPod一段时间，以便我们可以探索它提供的其他一些好处我们，让我们确认在执行skaffold run时确实安装了应用程序和相关的数据库。

```
kubectl -n $SKAFFOLD_DEPLOY_NAMESPACE get pods
```

------

watch.sh

我希望您已经看到了使用DevPod的好处。如果你是的话，你会很高兴还有很多东西要发现，还有很多好处我们还没有发现探索。何时我们导入一个项目，或者当我们使用其中一个快速入门创建一个新项目时，为我们创建的一个文件是watch.sh。这是一个简单而方便的脚本，结合了我们目前运行的命令，而且它还增加了一个你可以从它的名字猜到的转折点。让我们看看里面是什么。
![在这里插入图片描述](assets/20200613204534829.png)最后一行最重要，缺少uuid。

```shell
cat watch.sh | sed -e\
	's@skaffold@UUID=$(uuidgen) skaffold@g'\
	| tee watch.sh
```

Reflection(https://github.com/cespare/reflex)是一个很好的工具，它可以监视目录并在特定文件更改时重新运行命令。在我们的例子中，只要.go文件是改变了。那方法是，我们将构建一个二进制和一个容器映像，并且在每次更改任何结束的源代码文件时，我们将使用该映像部署一个Helm图表随走随走. 换言之，我们将永远删除运行最新代码的应用程序。那不是很漂亮吗？

> nohup
> nohup 命令运行由 Command参数和任何相关的 Arg参数指定的命令，忽略所有挂断（SIGHUP）信号。在注销后使用 nohup 命令运行后台中的程序。要运行后台中的 nohup 命令，添加 & （ 表示“and”的符号）到命令的尾部。
> nohup 是 no hang up 的缩写，就是不挂断的意思。
> nohup命令：如果你正在运行一个进程，而且你觉得在退出帐户时该进程还不会结束，那么可以使用nohup命令。该命令可以在你退出帐户/关闭终端之后继续运行相应的进程。
> 在缺省情况下该作业的所有输出都被重定向到一个名为nohup.out的文件中。

让我们退出DevPod并确认每次我们更改Go源代码时，它内部发生的事情确实会导致新的构建和安装。

```shell
exit
```

退出devpod。

在更改代码之前，我们将确认应用程序确实在运行。为此，我们需要指定给它的地址exposecontroller。我们可以通过检索相关入口的JSON来实现这一点，也可以引入另一个jx helper命令。我们将和前者一起去。

```
jx get applications
```

paste it instead of[…]in the command thatfollows.

```
URL=[...]
curl"$URL/demo/hello"
```

If the output is HTML with503 Service Temporarily Unavailable, you were too fast,and you did not give the process enough time. Please wait for a few moments until theapplication is up-and-running, and repeat thecurlcommand.
我们的下一个任务是更改源代码并确认新版本部署在个人开发环境中。

![在这里插入图片描述](assets/20200613232419759.png)上图就是工作模型图。对于理解jx 的工作非常重要。

### Working With The Code In The DevPod Using Browser-Based IDE 基于浏览器

我们可以回到DevPod并从终端修改代码。我们可以用一个类似的编辑来做。虽然我经常使用终端编辑器，但在项目中工作时，我发现它们是次优的。我相信vi、emacs、nano和类似的编辑器在处理单个脚本时是有用的，但在处理成熟的项目时不是那么好。称我懒惰，但我需要一个像IDE一样的通用工作室代码、IntelliJ、Eclipse或类似的东西。我需要语法突出显示，代码完整，能够一键跳转到一个函数中，以及IDEs。

那个问题是我们感兴趣的代码是运行在集群内的DevPod。

这意味着我们需要将本地文件从笔记本电脑同步到DevPod，或者我们可以远程使用代码。目前，我们对后一种选择感兴趣（稍后我们将探讨前者）。如果我们要使用远程文件，而我们还不打算在笔记本电脑和DevPod之间同步文件，唯一可用的选项就是使用远程IDE（除非您想使用其他基于终端的编辑器），我已经说过几次了，Jenkins X希望为您提供开发应用程序所需的一切。这甚至包括一个IDE。我们只需要弄清楚它在哪里，或者更准确地说，如何访问它。我们将通过引入另一个命令来实现这一点 。

```
jx open
```

![在这里插入图片描述](assets/20200613233227627.png)open命令列出了由Jenkins X管理并在群集。我们可以看到其中一个是ide，前缀是我们的用户名和我们正在使用的编程语言。在我看来那是vfarcic go-ide.如果我们将应用程序的名称作为参数添加到jx open命令中，它将（意外地，意外地）在默认浏览器中打开该应用程序。我们试试吧出去，求你了在执行下面的命令之前，请用*-ide应用程序的名称替换[…]。
jx open […]

修改看看把。
![Browser-Based IDE ](assets/20200613234518346.png)当我们的笔记本电脑中没有运行所有的工具时（除了jxcli），这是有益的。但是，基于浏览器的编辑器可能不是你的最佳选择。您可能会发现桌面IDE更简单、更快。或者，您可能在情感上依附于Visual Studio代码的桌面版、IntelliJ或其他任何您选择的编码武器。不用担心，我们也可以用。我们的下一个任务是将您喜爱的IDE与DevPods连接起来。但是，在这样做之前，我们将删除当前运行的DevPod，并开始一个新的DevPod。

```
jx delete devpod
```

### 将笔记本电脑中的代码同步到DevPod Synchronizing Code From A Laptop Into A DevPod

We’ll use ksync⁷⁹.

为了使事情更简单，jx有自己的ksync实现，它将与DevPod.

```
jx sync --daemon
jx create devpod\
	--label go\
	--sync\
	--batch-mode
```

we’ll add–sync argument. That will give it a signal that we want to use ksync to synchronize our local file system with the files in theDevPod.

### 集成Integrating IDEs With Jenkins X

我们看到可以使用本地文件，并让ksync将它们与DevPod同步。这使得我们可以使用我们最喜欢的IDE，同时从其他地方获得拥有完整环境的好处。但这还不是全部。我们可以将IDEs与Jenkins X集成在一起。你还记得本章开头的截图吗？这是我在处理本书中的示例时使用的Visual Studio代码设置。下面重复一遍，以防你忘记，不想再回去看。

------

记录一个问题，每次修改code都build，会不会卡死。

------

## Working With Pull Requests AndPreview Environments![在这里插入图片描述](https://img-blog.csdnimg.cn/20200614003751528.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Fpbmd5ZWppYXpodQ==,size_16,color_FFFFFF,t_70)

1.Create a feature branch
2.Work on the feature locally or through DevPods
3.Create a pull request when the feature is ready
4.Deploy the preview
5.Execute a set of automated validations that will confirm that the pull request works as expected
6.Review and approve the pull request
7.Create, deploy, and validate a new release in permanent environments (e.g., staging)
8.Promote the release to production (unless that part is automated as well)

### Creating A Kubernetes Cluster With Jenkins X AndImporting The Application

### Creating Pull Requests

我们可以自己创建一个分支，然后开始开发一个新的特性。

git checkout -b my-pr

因为我们已经定义了两次DB(一次在app图表中，一次在预览中)，我们最终安装了两个DB。我们不需要它，所以我们将禁用在应用程序图表中定义的那个，只保留预览图表中的那个(single replica DB)。

为了加快速度，我们还将禁用DB的持久性。由于预览是临时的，主要用于测试和手动验证，所以没有必要浪费时间创建一个persistent volume。

```yaml
echo"
db:
	enabled: false
	
preview-db:
	persistence:
		enabled: false"\
	| tee -a charts/preview/values.yaml
```

jx create pullrequest --title  ""   --body "" --batch-mode

当构建开始时，Jenkins X通知GitHub验证正在进行中，你应该能够在GitHub UI中确认。如果没有看到任何进展，则构建可能还没有启动，可能需要在一段时间后刷新屏幕。类似地，当build完成并且成功的时候，我们应该看到一个新的注释，说明PR已经建成，并且可以在使用预览环境[USER]-go-demo-6-pr-[PR_ID]。请记住，您可能需要刷新您的浏览器来查看pull request状态的变化。

github中可以查看，也可以

```
jx get previews
```

PULL  REQUEST   NAMESPACE   APPLICATION

```
PR_ADDR=[...]

curl "$PR_ADDR/demo/hello"
```

### Intermezzo 幕间剧、间奏曲

preview/values.yaml 和 项目/values.yaml

usePassword:  false

If you go through MongoDB Helm chart values, you’ll notice that one of them isusePassword.All we have to do is set it tofalse, both for previews as well as for the “official” application chartdeployed to permanent environments. We’

### Merging a PR

手动合并

```
jx get activity --watch --filter go-demo-6
```

观察一下

剩下的唯一一件事就是确认新版本确实正确地部署到了stage环境中。首先，我们将列出由Jenkins X管理的应用程序。

```
jx get applications
```



### Exploring Jenkins X Garbage Collection 垃圾回收

如果每个预览环境都永远运行，那就太愚蠢了。那将是对资源的浪费。因此，我们需要弄清楚如何删除作为pull request过程一部分部署的所有已经合并或关闭的内容。我们可以手动删除预览，但这会导致重复和可预测的事情中有太多的人工参与。我们可以创建一个脚本来为我们做这些，并定期执行(例如cronjob)。但是，在我们这么做之前，我们应该检查一下Jenkins X是否已经创建了一些Kubernetes CronJobs

kubectl get cronjobs

在撰写本文时(2019年3月)，有三个Jenkins X CronJobs。这三个都是定期(每三个小时)执行的垃圾收集器(gc)。ronjobs的名字应该能让你了解它们的用途。第一个删除旧的Jenkins X活动(Jenkins - X -gcactivities)，第二个处理完成或失败的Pods (Jenkins - X -gcpods)，而第三个消除与合并或关闭的pull请求相关的预览环境(Jenkins - X -gcpreviews)。

jx get previews

手动删除：

jx gc previews

Deleting helm release: jx-vfarcic-go-demo-6-pr-34

Deleting preview environment: vfarcic-go-demo-6-pr-34

Deleted environment vfarcic-go-demo-6-pr-34

这一次输出应该是空的。在其他一些情况下，我们可能希望只删除一个特定的预览，而保持其他的原封不动。我们可以使用jx delete preview command。在大多数情况下，我们不需要手动运行Jenkins X垃圾收集器。这就是ronjobs的作用。我向你们展示了这是可以做到的，但这并不意味着它应该做到。我相信比起浪费时间删除未使用的应用程序，你还有更令人兴奋的事情要做，因为系统已经为我们做了这些。在继续之前，我们将进入go-demo-6目录。

## Promoting Releases To Production

jx get applications --env staging

For what we’re trying to do, the important piece of the information is the version displayed in the STAGING column.



## Versioning Releases 版本控制

### 解释语义版本控制 Semantic Versioning Explained

### Versioning Releases Through Tags

### 从Jenkins XPipelines控制发布版本

### Customizing Versioning Logic

### Versioning With Maven, NodeJS, And Other Build Tools

## Going Serverless 探索Prow，Jenkins X管道运营商，和Tekton

## Implementing ChatOps 聊天室

### 通过chatops探索基本的Pull请求过程

### Exploring Additional Slash （其他斜杠命令）Commands

### 我们如何知道哪些斜杠命令是可用的？

## Using The Pipeline Extension Model

### Jenkins Jobs的发展以及我们如何达到基于yaml的Jenkins-x.yml格式

### 消除重复 getting rid of repetition

### Exploring Build Pack Pipelines

### Extending Build Pack Pipelines

### Extending Environment Pipelines

## Extending Jenkins X Pipelines

## 使用Jenkins X定义和运行无服务器部署

## Choosing The Right DeploymentStrategy

## 将GitOps原理应用于JenkinsX

## Managing Third-Party Applications